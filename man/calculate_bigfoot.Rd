% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_pixel_footstats.R
\name{calculate_bigfoot}
\alias{calculate_bigfoot}
\alias{calculate_bigfoot.sf}
\alias{calculate_bigfoot.sp}
\alias{calculate_bigfoot.character}
\title{calculate_bigfoot: Gridded feature statistics for large sets of
  building footprint polygons}
\usage{
calculate_bigfoot(
  X,
  metrics = "all",
  focalRadius = 0,
  minArea = NULL,
  maxArea = NULL,
  controlUnits = NULL,
  controlDist = NULL,
  zoneMethod = "centroid",
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = tempdir(),
  outputTag = NULL,
  tries = 100,
  verbose = FALSE
)

\method{calculate_bigfoot}{sf}(
  X,
  metrics = "all",
  focalRadius = 0,
  minArea = NULL,
  maxArea = NULL,
  controlUnits = NULL,
  controlDist = NULL,
  zoneMethod = "centroid",
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = tempdir(),
  outputTag = NULL,
  tries = 100,
  verbose = FALSE
)

\method{calculate_bigfoot}{sp}(
  X,
  metrics = "all",
  focalRadius = 0,
  minArea = NULL,
  maxArea = NULL,
  controlUnits = NULL,
  controlDist = NULL,
  zoneMethod = "centroid",
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = tempdir(),
  outputTag = NULL,
  tries = 100,
  verbose = FALSE
)

\method{calculate_bigfoot}{character}(
  X,
  metrics = "all",
  focalRadius = 0,
  minArea = NULL,
  maxArea = NULL,
  controlUnits = NULL,
  controlDist = NULL,
  zoneMethod = "centroid",
  template = NULL,
  tileSize = c(500, 500),
  parallel = TRUE,
  nCores = max(1, parallel::detectCores() - 1),
  outputPath = tempdir(),
  outputTag = NULL,
  tries = 100,
  verbose = FALSE
)
}
\arguments{
\item{X}{object with building footprint polygons. This argument can take
multiple spatial types, including \code{sf} and \code{sp}, or a filepath
string to a file, or a list where each member provides a spatial object or
a filepath string.}

\item{metrics}{character vector. Names of footprint statistics in the form of
"fs_area_mean", etc. Other options include \code{ALL} or \code{NODIST} to
calculate all available metrics and all except nearest neighbour distances,
respectively.}

\item{focalRadius}{numeric. Distance in meters for a buffer around each
template pixel. Creates a focal processing window for metrics.}

\item{minArea}{numeric. Minimum footprint area to filter \code{X}.}

\item{maxArea}{numeric. Maximum footprint area to filter \code{X}.}

\item{controlUnits}{(Optional) named list to control the units used in the
geometry functions. Elements can include \code{areaUnit}, \code{perimUnit},
and \code{distUnit}. The values for these items should be strings that can
be coerced into a \code{units} object.}

\item{controlDist}{(Optional) named list to override default options for
distance calculations. Elements can include \code{maxSearch} and
\code{method}. Ignored if \code{metrics} does not include a distance
calculation. See \code{\link[foot]{fs_nndist}}.}

\item{zoneMethod}{One of \code{'centroid', 'intersect', 'clip'}. How should
footprints which span pixel zones be allocated? Default is by its
\code{'centroid'}. See \code{\link[foot]{zonalIndex}} for details.}

\item{template}{(optional). When creating a gridded output, a supplied
\code{stars} or \code{raster} dataset to align the data.}

\item{tileSize}{number of pixels per side of a tile. Can be a vector of
length 2 (rows, column pixels). Ignored if n provided. Default is 1000.}

\item{parallel}{logical. Should a parallel backend be used to process the
tiles.}

\item{nCores}{number of CPU cores to use if \code{parallel} is \code{TRUE}.
Default is 1 less than the available CPUs.}

\item{outputPath}{(optional). When creating a gridded output, a path for the
location of the output. Default is the temp directory.}

\item{outputTag}{(optional). A character string that will be added to the
beginning of the output name for the gridded files.}

\item{tries}{(optional). The number of attempts to write a tile to the output
file. Default is 100.}

\item{verbose}{logical. Should progress messages be printed. Default
\code{False}.}
}
\value{
Invisible. Returns a vector of paths to the output files.
}
\description{
Calculate selected metrics of building footprints for
  high-spatial resolution gridded outputs.
}
\details{
calculate_bigfoot

\code{calculate_bigfoot} provides a wrapper for a workflow to
  process vector polygons of structures to create a gridded output summary of
  morphology measures. The function wraps \code{calculate_footstats} along
  with other geometry functions of \code{foot} and read/writing functions
  from \code{stars} and \code{sf}.
  
  The suggested way of using this function is to supply character strings for
  \code{X} and \code{template} rather than objects. Using strings is more
  memory-efficient. This function processes based on 'tiles' or sub-regions
  of the template grid and will only read in the portion of the object needed
  for the calculations.
}
\examples{
data("kampala", package="foot")
buildings <- kampala$buildings
templateGrid <- kampala$mastergrid

calculate_bigfoot(X=buildings,
                  metrics=c("shape_mean",
                            "count",
                            "perim_total"),  
                  controlUnits=list(areaUnit="m^2"),
                  minArea=50,  # footprints must be larger than 50 m^2
                  maxArea=1000,  # footprints must be smaller than 1000 m^2
                  template=templateGrid, 
                  outputPath=tempdir(),  
                  outputTag="kampala",
                  parallel=FALSE,
                  verbose=TRUE)  

# read one of the output files and plot as a raster layer
outGrid <- raster::raster(file.path(tempdir(), "kampala_count.tif"))
raster::plot(outGrid)

}
