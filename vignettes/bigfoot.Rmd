---
title: "Gridded footprint calculation layers"
date: 'October 21, 2020'
description: >
  Building footprints or polygons representing the outline shape of structures
  can provide a unique data source for studying urban areas at high spatial
  resolutions. This vignette will demonstrate how to use the `foot` package to
  produce high-spatial resolution gridded data layers of geometric and
  morphological measures, potentially for large regions.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Gridded footprint calculation layers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



The `foot` package was developed by WorldPop at the University of Southampton
([www.worldpop.org](https://www.worldpop.org)) to support geometric calculations
and zonal summaries of measures from building footprint polygons. The
`vignette("footsteps", package="foot")` provides an introduction to package and 
the functionality of calculating and summarising morphology measures. This 
vignette builds on those methods and demonstrates a more advanced workflow to 
produce gridded summaries of buildings measures. In particular, the focus is on 
using `foot::calculate_bigfoot()` in order how to handle very large (i.e. 
national-scale) datasets of building footprints.

This vignette use a portion of Ordnance Survey's OS OpenMap Local data of
building footprint polygons. The polygons cover the area of Southampton. These
data were originally processed and made available by Alasdair Rae
([http://ajrae.staff.shef.ac.uk/buildings/](http://ajrae.staff.shef.ac.uk/buildings/))
under the [OS OpenData License](http://os.uk/opendata/licence). The data contain
Ordnance Survey data Â© Crown copyright and database right 2018.


```r
library(foot)
```

## Calculations with `foot`

The central function for producing gridded layers is `calculate_bigfoot`. It is
designed to support processing large sets of building polygons into gridded
(GeoTiff) summary layers. The procedure is intended to be more memory-efficient
by splitting the processing area into "tiles" which can then be handled
individually or in parallel. This function works as a wrapper to
`calculate_footstats` as well as several helper functions within the `foot`
package for managing the input/output and creating and indexing spatial zones.
Because it extends `calculate_footstats`, this function takes the same `what=`
and `how=` arguments to define the summary operations. Likewise the available
metrics are available from `list_fs()`.

By default the function performs calculations in parallel (which can be changed
with the argument `parallel=FALSE`). Users can adjust the number of computing 
cores used with the argument `nCores=`) To monitor the supplied values and
processing steps, set `verbose=TRUE`.

### Main inputs

Users need to supply `calculate_bigfoot()` with:

* A path to a file of building footprints in a spatial vector data format (e.g.
`.gpkg`, `.shp`)
* A filepath to a template gridded dataset specifying the extent and resolution
for the outputs (e.g. `.tif`)

For example:


```r
# create paths to files
bldgPath <- file.path(dir, "soton_buildings.gpkg")
sotonGrid <- file.path(dir, "soton_borough_100m.tif")
```

While `R` objects can be supplied for these parameters, it is recommended to
supply character strings of paths to the files. `calculate_bigfoot` will only
read the subset of data needed for a particular processing step. This is
intended to allow users to process much larger datasets than can be held in
memory.

### Basic calculations

With the key inputs for the file paths set, the processing can be executed with
a single function.


```r
# basic function call with default parameters
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid,
                  what="settled", how="binary",
                  verbose=TRUE)
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> Setting up cluster...
#> Begin parallel tile processing: 2020-10-21 16:08:59
#> 
#> Finished processing all tiles: 2020-10-21 16:09:07
```
The documentation and default parameters are available from
`?foot::calculate_bigfoot`.

The arguments `what` and `how` are the same as for `calculate_footstats`. They
provide a character or list list of character names or characteristics (i.e.
columns within the building footprint attributes) and summary functions,
respectively. The available metrics can be retrieved with `list_fs()`.

### Specifying outputs

By default the outputs of `bigfoot` are saved as GeoTiffs in the user's working
directory (`getwd()`). Each grid is named by the combination of characteristics
and summary function. The example below shows how to retrieve an output of
`calculate_bigfoot`.


```r
# retrieve the gridded outputs
outGrid <- raster::raster(file.path(getwd(), "settled_binary.tif"))

raster::plot(outGrid)
```

<img src="man/figures/REAsDME-Fig1-1.png" title="Binary settled raster for Southampton at 100m resolution" alt="Binary settled raster for Southampton at 100m resolution" width="100%" />

Users can specify an output path to another folder location (`outputPath=`).
Additionally a "tag" can be specified as a parameter to the function
(`outputTag=`). The tag is appended to the beginning of each file name with an
underscore. This can be useful for identifying different outputs. These options
are demonstrated in the code block below.


```r
# basic function call specifying output parameters
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid,
                  what="settled", how="binary",
                  outputPath=file.path(tempdir()), # output location
                  outputTag="Soton",
                  verbose=TRUE)
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> Setting up cluster...
#> Begin parallel tile processing: 2020-10-21 16:09:08
#> 
#> Finished processing all tiles: 2020-10-21 16:09:15
```

### Multiple metrics

As with `calculate_footstats` multiple metrics and summary statistics can be
supplied to `bigfoot` as a list or nested lists grouping characteristics and
functions. 


```r
# re-running the basic call with multiple metrics
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid, 
                  what=list(list("settled"), list("area")),
                  how=list(list("binary"), list("cv")),
                  outputPath=tempdir(),  
                  outputTag="soton")  
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> Setting up cluster...
#> Begin parallel tile processing: 2020-10-21 16:09:15
#> 
#> Finished processing all tiles: 2020-10-21 16:09:25
```

```r
# retrieve the gridded outputs Note: must add the 'tag' to the filename
outGrid <- raster::raster(file.path(tempdir(), "soton_area_cv.tif"))

raster::plot(outGrid)
```

<img src="man/figures/REAsDME-Fig2-1.png" title="Coeff. of variation in building area for Southampton at 100m resolution" alt="Coeff. of variation in building area for Southampton at 100m resolution" width="100%" />

### Focal window statistics

In the examples above, the footprint statistics are summarised for buildings
whose centroid intersect the pixels of the template grid. Internally this is
handled by `zonalIndex()`. The method for assigning footprints to spatial zones
can be adjusted using `controlZone` options.

It is also possible to extend those zones beyond the individual pixels and to
calculate and summarise building footprints from within a local, circular window
centred on each pixel. The output is still associated with each template grid
cell. This process is similar to a moving window or filter analysis. The focal
radius distance is specified in meters.

A hypothetical example of using a 300 m focal radius around a pixel centroid to
construct a local zone and using building centroids is shown below.
<img src="man/figures/REAsDME-Fig3-1.png" title="Example of 300 m focal radius. Selected footprints are highlighted in red" alt="Example of 300 m focal radius. Selected footprints are highlighted in red" width="100%" />

Below is an example of applying a 300 m focal radius in action for a gridded
output layer.


```r
# moving focal window calculations
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid,
                  what=list(list("area"), list("perimeter")),
                  how=list(list("mean"), list("sum")),
                  focalRadius=300,  # buffer radius in meters
                  outputPath=tempdir(), 
                  outputTag="soton")
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> Setting up cluster...
#> Begin parallel tile processing: 2020-10-21 16:09:26
#> 
#> Finished processing all tiles: 2020-10-21 16:10:22
```
Creating the focal window is handled by `calculate_bigfoot`. The focal window is
also taken into consideration by the function when creating processing tiles -
the footprints are extract from outside the tile, in neighbouring areas, to
prevent edge effects

Note that when a focal radius is specified, this value is always appended to the
end of the file names so that the outputs can be identified.

```r
# Note that the filename includes both a tag and a focal radius value
outGrid <- raster::raster(file.path(tempdir(), "soton_perimeter_sum_300.tif"))

raster::plot(outGrid)
```

<img src="man/figures/REAsDME-Fig4-1.png" title="Total building perimeter in a 300m radius window. Output at a 100m resolution" alt="Total building perimeter in a 300m radius window. Output at a 100m resolution" width="100%" />

## Options and finer control

The `calculate_bigfoot` function is set up with default values that should work
under most conditions; however, there is additional flexibility for users to
specify alternative parameters. 

### Specifying geometry units

To override the default units used in the geometry calculations, a named list of
unit strings can be supplied to the `controlUnits` argument. This list can
contain named items for `areaUnit`, `perimUnit`, and `distUnit`. The default
values are meters ("m") and square meters ("m^2") The value of each item should
be coercible with `units::as_units`.


```r
# change the default units used to calculate area and distance
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid, 
                  what=list(list("area"), list("perimeter")),
                  how=list(list("mean"), list("sum")),
                  controlZone=list("method"="intersect"), # join by intersection
                  controlUnits=list(areaUnit="m^2",  # change default units
                                    perimUnit="km"),
                  outputPath=tempdir(),  
                  outputTag="soton",
                  parallel=FALSE,
                  verbose=TRUE)  
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> 
#> Tile: 1 of 1
#> Reading footprints 
#> Reading layer `soton_buildings' from data source `/home/jochem/Documents/projects/0_data/soton_buildings.gpkg' using driver `GPKG'
#> Simple feature collection with 31289 features and 10 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XYZ
#> bbox:           xmin: 436985.8 ymin: 109485.5 xmax: 447734.5 ymax: 117564.1
#> z_range:        zmin: 0 zmax: 0
#> projected CRS:  OSGB 1936 / British National Grid
#> 
#> Reading template grid 
#> Selecting metrics 
#> Setting control values. 
#> Creating zonal index 
#> Pre-calculating areas 
#> Pre-calculating perimeters 
#> 
#> Calculating  2  metrics ... 
#>    area mean  
#>    perimeter sum  
#> Finished calculating metrics. 
#> Writing output tiles 
#> Finished writing grids
#> 
#> Finished processing all tiles: 2020-10-21 16:10:30

# plot the total perimeter, measured in kilometres
outGrid <- raster::raster(file.path(tempdir(), "soton_perimeter_sum.tif"))
raster::plot(outGrid)
```

<img src="man/figures/REAsDME-Fig5-1.png" title="Total building perimeter in KM" alt="Total building perimeter in KM" width="100%" />
### Filtering buildings

In some settings it may be preferable to exclude very small and/or very large
building footprint polygons. The lower and upper bounds for filtering can be
specified with `minArea` and `maxArea` in the `filter` argument. The values for
these filters are in the same units specified by `controlUnits` or the default
value for area calculations. Note that an "area" footprint statistic does not
need to be requested as this characteristic is automatically calculated to
enable filtering.


```r
# Filtering: # footprints must be larger than 50 m^2 and smaller than 1000 m^2
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid, 
                  what=list(list("shape"), list("settled"), list("perimeter")),
                  how=list(list("mean"), list("count"), list("sum")),
                  controlUnits=list(areaUnit="m^2"),
                  filter=list(minArea=50, maxArea=1000),
                  outputPath=tempdir(),  
                  outputTag="soton",
                  parallel=FALSE,
                  verbose=TRUE)  
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> 
#> Tile: 1 of 1
#> Reading footprints 
#> Reading layer `soton_buildings' from data source `/home/jochem/Documents/projects/0_data/soton_buildings.gpkg' using driver `GPKG'
#> Simple feature collection with 31289 features and 10 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XYZ
#> bbox:           xmin: 436985.8 ymin: 109485.5 xmax: 447734.5 ymax: 117564.1
#> z_range:        zmin: 0 zmax: 0
#> projected CRS:  OSGB 1936 / British National Grid
#> 
#> Reading template grid 
#> Selecting metrics 
#> Setting control values. 
#> Creating zonal index 
#> Pre-calculating areas 
#>  Filtering features larger than 50 
#>  Filtering features smaller than 1000 
#> Pre-calculating perimeters 
#> Pre-calculating shape 
#> 
#> Calculating  3  metrics ... 
#>    shape mean  
#>    settled count  
#>    perimeter sum  
#> Finished calculating metrics. 
#> Writing output tiles 
#> Finished writing grids
#> 
#> Finished processing all tiles: 2020-10-21 16:10:57
```

In the map of the results below, each pixel is the count of footprints present.
Note the smaller number of structures and sparseness of structures in pixels
around the lower center portions of the image. This corresponds with the study
region's central business district and industrial areas with fewer, but larger
structures.

```r
outGrid <- raster::raster(file.path(tempdir(), "soton_settled_count.tif"))

raster::plot(outGrid)
```

<img src="man/figures/REAsDME-Fig6-1.png" title="Count of buildings with area &gt;50 m^2 and &lt;1000 m^2" alt="Count of buildings with area &gt;50 m^2 and &lt;1000 m^2" width="100%" />

### Tile size

The size of the processing tiles, specified in pixel dimensions (rows, columns)
can be an important factor in the efficiency of the calculations. Smaller tile
regions result in fewer building footprints being read/processed at one time,
but there is an overhead computational cost of reading/writing files. The
default value is 500 pixels. For the small demonstration shown here that results
in one tile for the whole region. To show multiple tile processing, a small size
is supplied and the processing is done in parallel with verbose output.


```r
calculate_bigfoot(X=bldgPath,
                  template=sotonGrid,
                  what="compact",
                  how="mean",
                  tileSize=c(75, 75),  # rows x columns in pixels
                  parallel=FALSE,
                  verbose=TRUE)
#> Selecting metrics 
#> Setting control values. 
#> Creating template output grids 
#> Creating list of processing tiles 
#> 
#> Tile: 1 of 4
#> Reading footprints 
#> Reading layer `soton_buildings' from data source `/home/jochem/Documents/projects/0_data/soton_buildings.gpkg' using driver `GPKG'
#> Simple feature collection with 19448 features and 10 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XYZ
#> bbox:           xmin: 436985.8 ymin: 110061.1 xmax: 444270.8 ymax: 117564.1
#> z_range:        zmin: 0 zmax: 0
#> projected CRS:  OSGB 1936 / British National Grid
#> 
#> Reading template grid 
#> Selecting metrics 
#> Setting control values. 
#> Creating zonal index 
#> Pre-calculating compactness 
#> 
#> Calculating  1  metrics ... 
#>    compact mean  
#> Finished calculating metrics. 
#> Writing output tiles 
#> Finished writing grids
#> 
#> Tile: 2 of 4
#> Reading footprints 
#> Reading layer `soton_buildings' from data source `/home/jochem/Documents/projects/0_data/soton_buildings.gpkg' using driver `GPKG'
#> Simple feature collection with 11585 features and 10 fields (with 1 geometry empty)
#> geometry type:  MULTIPOLYGON
#> dimension:      XYZ
#> bbox:           xmin: 444148.1 ymin: 109954.1 xmax: 447734.5 ymax: 116557.5
#> z_range:        zmin: 0 zmax: 0
#> projected CRS:  OSGB 1936 / British National Grid
#> 
#> Reading template grid 
#> Selecting metrics 
#> Setting control values. 
#> Creating zonal index 
#> Pre-calculating compactness 
#> 
#> Calculating  1  metrics ... 
#>    compact mean  
#> Finished calculating metrics. 
#> Writing output tiles 
#> Finished writing grids
#> 
#> Tile: 3 of 4
#> Reading footprints 
#> Reading layer `soton_buildings' from data source `/home/jochem/Documents/projects/0_data/soton_buildings.gpkg' using driver `GPKG'
#> Simple feature collection with 68 features and 10 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XYZ
#> bbox:           xmin: 442517.3 ymin: 109485.5 xmax: 444219 ymax: 110101.5
#> z_range:        zmin: 0 zmax: 0
#> projected CRS:  OSGB 1936 / British National Grid
#> 
#> Reading template grid 
#> Selecting metrics 
#> Setting control values. 
#> Creating zonal index 
#> Pre-calculating compactness 
#> 
#> Calculating  1  metrics ... 
#>    compact mean  
#> Finished calculating metrics. 
#> Writing output tiles 
#> Finished writing grids
#> 
#> Tile: 4 of 4
#> Reading footprints 
#> Reading layer `soton_buildings' from data source `/home/jochem/Documents/projects/0_data/soton_buildings.gpkg' using driver `GPKG'
#> Simple feature collection with 311 features and 10 fields
#> geometry type:  MULTIPOLYGON
#> dimension:      XYZ
#> bbox:           xmin: 444207.5 ymin: 109493.6 xmax: 445655.3 ymax: 110117.8
#> z_range:        zmin: 0 zmax: 0
#> projected CRS:  OSGB 1936 / British National Grid
#> 
#> Reading template grid 
#> Selecting metrics 
#> Setting control values. 
#> Creating zonal index 
#> Pre-calculating compactness 
#> 
#> Calculating  1  metrics ... 
#>    compact mean  
#> Finished calculating metrics. 
#> Writing output tiles 
#> Finished writing grids
#> 
#> Finished processing all tiles: 2020-10-21 16:11:09
```
## Next steps

This vignette has provided an overview of how to create gridded outputs layers
summarising building footprint morphology measures. This workflow uses
`calculate_bigfoot` and is designed to work for large sets of data through tiled
read/writing and processing these tiles in parallel. The `bigfoot` functionality
extends and makes use of `footstats`. Both of these functions can take
use-supplied and custom summary functions. This advanced usage is demonstrated
in `vignette("cobbler", package="foot")`.

***

```r
sessionInfo()
#> R version 3.6.3 (2020-02-29)
#> Platform: x86_64-pc-linux-gnu (64-bit)
#> Running under: Ubuntu 20.04.1 LTS
#> 
#> Matrix products: default
#> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
#> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
#> 
#> locale:
#>  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C               LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8     LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8    LC_PAPER=en_GB.UTF-8      
#>  [8] LC_NAME=C                  LC_ADDRESS=C               LC_TELEPHONE=C             LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
#> 
#> attached base packages:
#> [1] stats     graphics  grDevices utils     datasets  methods   base     
#> 
#> other attached packages:
#> [1] stars_0.4-1  abind_1.4-5  foot_0.5     knitr_1.28   sf_0.9-2     raster_3.1-5 sp_1.4-1    
#> 
#> loaded via a namespace (and not attached):
#>  [1] pkgload_1.0.2      foreach_1.4.8      StanHeaders_2.19.2 assertthat_0.2.1   highr_0.8          stats4_3.6.3       yaml_2.2.1         remotes_2.1.1      sessioninfo_1.1.1  pillar_1.4.3      
#> [11] backports_1.1.5    lattice_0.20-40    glue_1.4.0         digest_0.6.25      colorspace_1.4-1   htmltools_0.4.0    pkgconfig_2.0.3    devtools_2.3.0     rstan_2.19.3       purrr_0.3.3       
#> [21] scales_1.1.0       processx_3.4.2     whisker_0.4        downlit_0.2.0      tibble_3.0.1       ggplot2_3.3.0      usethis_1.6.1      ellipsis_0.3.0     withr_2.1.2        cli_2.0.2         
#> [31] magrittr_1.5       crayon_1.3.4       memoise_1.1.0      evaluate_0.14      ps_1.3.2           fs_1.3.1           fansi_0.4.1        doParallel_1.0.15  xml2_1.3.1         lwgeom_0.2-3      
#> [41] class_7.3-16       pkgbuild_1.0.6     loo_2.2.0          tools_3.6.3        data.table_1.12.8  prettyunits_1.1.1  matrixStats_0.56.0 formatR_1.7        lifecycle_0.2.0    stringr_1.4.0     
#> [51] munsell_0.5.0      callr_3.4.3        packrat_0.5.0      compiler_3.6.3     pkgdown_1.6.1      e1071_1.7-3        rlang_0.4.5        classInt_0.4-3     units_0.6-6        grid_3.6.3        
#> [61] iterators_1.0.12   rstudioapi_0.11    rmarkdown_2.1      testthat_2.3.2     gtable_0.3.0       codetools_0.2-16   inline_0.3.15      DBI_1.1.0          rematch2_2.1.1     R6_2.4.1          
#> [71] gridExtra_2.3      dplyr_0.8.5        rgdal_1.4-8        filelock_1.0.2     rprojroot_1.3-2    KernSmooth_2.23-16 desc_1.2.0         stringi_1.4.6      parallel_3.6.3     Rcpp_1.0.4.6      
#> [81] vctrs_0.2.4        tidyselect_1.0.0   xfun_0.12
```

