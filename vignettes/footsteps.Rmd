---
title: "Basic building footprint calculations"
date: 'October 01, 2020'
description: >
  Building footprints or polygons representing the outline shape of structures
  can provide a unique data source for studying urban areas at high spatial
  resolutions. This vignette will introduce the `foot` package and demonstrate
  some of the tools provided to calculate summary measures of geometric
  properties and to produce tabular, zonal, and gridded outputs.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic building footprint calculations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `foot` package was developed by members of the WorldPop Research Group at
the University of Southampton ([www.worldpop.org](https://www.worldpop.org)) to
support geometric and morphological calculations from building footprint
polygons. Two main wrapper functions provide standardised workflows for
processing building polygons to summarise the metrics within polygons or on a
gridded surface.

```r
library(foot)
```
This vignette will demonstrate some of the core functionality in the package,
including:

* The available measurements and summary statistics
* How to define different types of spatial zones for summaries
* Example workflows to produce tabular and gridded output

To demonstrate the package, this vignette will use a supplied sample of building
footprint polygons produced by Microsoft Bing Maps
([Source](https://github.com/microsoft/Uganda-Tanzania-Building-Footprints))
from an area in Kampala, Uganda. These footprints have been reprocessed into a
spatial data format which can be read with `sf`.

## Load the sample dataset

```r
data("kampala")

buildings <- kampala$buildings
adminzones <- kampala$adminZones
clusters <- kampala$clusters
```

The sample dataset is a list of four named objects: 

* "buildings" - polygons of building footprints in `sf` format. Contains 8480
records. 
* "mastergrid" - geoTiff `RasterLayer` aligned to WorldPop datalayers. This will
be used as a template for producing other gridded outputs
* "adminZones" - 34 polygons in `sf` format for zonal statistics 
* "clusters" - 10 small polygons in `sf` format for sample sites

Note that the adminZones and cluster boundaries are purely artificial and were
created for demonstration purposes only.

For more information, see `?kampala`.

![Sample buildings and zones in Kampala](figure/unnamed-chunk-3-1.png)

## Calculations with `foot`
All function names for calculating metrics begin with `fs_` (short for
"footprint statistic"). The second part of the name includes the group of
measures (e.g. area or perimeter), and finally an abbreviation for the summary
statistic (e.g. 'cv' for coefficient of variation or 'sd' for standard
deviation).

### Available metrics and summary measures
Currently implemented are measures for:

* presence (binary and count)
* area
* perimeter
* Euclidean nearest neighbour distance
* nearest neighbour index
* angle of rotation
* compactness and shape indices

A table of metrics is available in the package `foot::fs_footprint_metrics`.
Helper functions are also available to look up function names, groupings, and
units. See `?get_fs_metrics`.


## Basic usage
The simplest usage of `foot` involves supplying a set of building footprints to
the desired metric and summary function.


```r
# mean of all footprint areas
built_area <- fs_area_mean(buildings)
#> Warning in fs_area_mean_calc(X, index, unit): No index found, treating as one group.

built_area
#>    index fs_area_ha_mean
#> 1:     1 0.02631865 [ha]

# standard deviation of perimeters
perim_sd <- fs_perim_sd(buildings)
#> Warning in fs_perim_sd_calc(X, index, unit): No index found, treating as one group.

perim_sd
#>    index fs_perim__sd
#> 1:     1     58.46233

# median of areas
area_med <- fs_area_median(buildings, unit = "m^2")
#> Warning in fs_area_median_calc(X, index, unit): No index found, treating as one group.
area_med
#>    index fs_area_m^2_median
#> 1:     1     118.3406 [m^2]
```

With no other argument supplied, all the footprints are treated as coming from
the same zone for the summary. Default unit values are used for geometry
measurements, unless otherwise specified (see third example). All functions
return the same format - a `data.table` with a column for the index and the
named column for the summarised footprint metric.

There is also an option to supply pre-calculated column to each function with
the `col=` argument. If a pre-calculated geometry value exists, that field can
be used or, if it is absent, the appropriate geometries needed for the metric
will be calculated.

All functions follow the same parameter template, and, because the first
argument is always data, all the functions allow for "piping" syntax.


```r
# random sample of buildings
result <- buildings %>%
          dplyr::filter(FID_1 %in% sample(FID_1, 1000)) %>%
          fs_area_mean()
#> Warning in fs_area_mean_calc(X, index, unit): No index found, treating as one group.

# show the resulting table
result
#>    index fs_area_ha_mean
#> 1:     1 0.02476811 [ha]
```

Most low-level geometry calculations rely on `sf` and `lwgeom` and users need to
have recent versions of these packages installed.

### Nearest neighbour distances
Distances can be calculated between footprints (represented as points or as
polygons), between footprints and other objects, and/or within a maximum search
distance.


```r
# nearest distance for the first 10 buildings to any other building measured
# between polygon edges
fs_nndist(buildings[1:10, ], buildings, maxSearch = 200, unit = "m")
#> although coordinates are longitude/latitude, st_intersects assumes that they are planar
#> Warning in st_centroid.sfc(sf::st_as_sfc(sf::st_bbox(X))): st_centroid does not give correct centroids for longitude/latitude data
#> although coordinates are longitude/latitude, st_intersects assumes that they are planar
#> Units: [m]
#>  [1]  3.961359  7.894813  1.019971 22.306277  2.484471 16.257603  0.951225  1.864305  2.607113  2.291474

# omitting 'Y' measures distance among the footprints supplied
fs_nndist(buildings[1:10, ], maxSearch = NULL)  # unrestricted distance
#> although coordinates are longitude/latitude, st_intersects assumes that they are planar
#> Units: [m]
#>  [1]  83.55586  83.55586  72.16085  72.16085  94.94137  94.94137 202.23022 209.11098 202.23022 417.35128
```

Note that distance calculations are slower for polygons and for unprojected
coordinate systems. It is recommended that a maximum search radius is always
used. Internally the calculations are done with a `data.table` to benefit from
multithreading capabilities.

### Rotation angles
A less conventional geometric measure is derived from the rotated bounding
rectangle. This is the rectangle enclosing a polygon (or set of points) which
has been rotated to minimise the area. In contrast, a "bounding box" for a shape
is always oriented along the x and y axes.


```r
# To obtain the rotated rectangle as a spatial object
mbr <- fs_mbr(buildings[5, ], returnShape = T)

plot(sf::st_geometry(buildings[5, ]))
plot(mbr, border = "red", add = T)
```

![plot of chunk unnamed-chunk-7](figure/unnamed-chunk-7-1.png)

```r

# Or obtain just the angle
fs_mbr(buildings[5, ], returnShape = F)
#>        X 
#> 358.8693
```

The angles can be summarised as an entropy measure and normalised to describe
how much the angles of structures depart from a regular grid pattern (available
in `fs_angle_entropy()`).


## Creating and supplying zone indices
Rather than treating all features as a single summary zone, it's more common to
want to summarise metrics within smaller areas. There are several ways to supply
information on the zones.

### Index by vector
A vector of indices for a zone can be supplied to the functions as a column
name, column number, or passed as a standalone vector object. The length of a
vector of indices must match the number of building polygons.


```r
# create a vector of ten random zones
id <- sample(1:10, nrow(buildings), replace = T)
buildings$id <- id  # add it to the buildings object
table(buildings$id)  # splitting observations into 10 groups
#> 
#>   1   2   3   4   5   6   7   8   9  10 
#> 470 499 499 502 517 464 465 459 493 472

# pass the index by name
fs_area_total(buildings, index = "id")  # note default units
#>     index fs_area_ha_total
#>  1:     1   15.398450 [ha]
#>  2:     2   12.815166 [ha]
#>  3:     3   10.577883 [ha]
#>  4:     4   16.834218 [ha]
#>  5:     5   12.632468 [ha]
#>  6:     6    9.806395 [ha]
#>  7:     7   12.938074 [ha]
#>  8:     8   12.612959 [ha]
#>  9:     9   11.044551 [ha]
#> 10:    10   12.722124 [ha]

# pass the index by column number
fs_count(buildings, index = 3)
#>     index fs_count
#>  1:     1      470
#>  2:     2      499
#>  3:     3      499
#>  4:     4      502
#>  5:     5      517
#>  6:     6      464
#>  7:     7      465
#>  8:     8      459
#>  9:     9      493
#> 10:    10      472

# pass a separate vector object
print(fs_angle_entropy(buildings, index = id, normalize = T))
#>     index fs_angle_entropy
#>  1:     1       0.08379157
#>  2:     2       0.06151392
#>  3:     3       0.03357253
#>  4:     4       0.05698299
#>  5:     5       0.03795802
#>  6:     6       0.07766643
#>  7:     7       0.06703642
#>  8:     8       0.08310194
#>  9:     9       0.06913862
#> 10:    10       0.05821359
```

### Index by shape
Rather than supplying a pre-calculated column or vector of zonal indices,
buildings can be assigned a zone based on a spatial join. Creating an index from
a spatial object returns a field called "zoneID" which other calculation
functions in `foot` can use.


```r
# Return a table of index values based on administrative zone polygons
zID <- zonalIndex(buildings, adminzones, returnObject = F)
zID  # the xID column are row numbers
#>        xID zoneID
#>    1:  145      1
#>    2:  338      1
#>    3:  655      1
#>    4:  995      1
#>    5: 2869      1
#>   ---            
#> 4846: 4829     34
#> 4847: 4830     34
#> 4848: 4831     34
#> 4849: 4832     34
#> 4850: 4833     34

# Alternatively, join the zones to create and return a new spatial object A
# custom zone name can be added but must be supplied to the summary functions
zObj <- zonalIndex(buildings, clusters, zoneField = "Id", returnObject = T)
zObj
#> Simple feature collection with 350 features and 3 fields
#> geometry type:  POLYGON
#> dimension:      XY
#> bbox:           xmin: 32.60631 ymin: 0.328119 xmax: 32.63543 ymax: 0.349785
#> geographic CRS: WGS 84
#> First 10 features:
#>    FID_1 id Id                       geometry
#> 1   6293  6  1 POLYGON ((32.60744 0.338575...
#> 2  17706  5  1 POLYGON ((32.60664 0.339347...
#> 3  29106  3  1 POLYGON ((32.60719 0.339276...
#> 4  53393  1  1 POLYGON ((32.60779 0.339691...
#> 5  57187  9  1 POLYGON ((32.60826 0.338663...
#> 6  59496  4  1 POLYGON ((32.60692 0.339387...
#> 7  68588  2  1 POLYGON ((32.60791 0.338896...
#> 8  68590  1  1 POLYGON ((32.60768 0.339633...
#> 9  72387  3  1 POLYGON ((32.60777 0.338962...
#> 10 78504  3  1 POLYGON ((32.60702 0.338636...
```

When using a new spatial object which has been joined to its zones, remember to
supply the name of the zone field if a custom name was used.

```r
# use the new object
zarea <- fs_area_mean(zObj, index = "Id")
clusters <- merge(clusters, zarea, by.x = "Id", by.y = "index")
plot(clusters["fs_area_ha_mean"])
```

![plot of chunk unnamed-chunk-10](figure/unnamed-chunk-10-1.png)

The `zonalIndex` function works by spatial intersection. This produces some
(potentially useful) side effects that users need to be aware of.

The default behaviour is for any intersecting structure to included in the zone.

```r
# Note the selected structures extend beyond the cluster boundary
plot(sf::st_geometry(clusters)[[6]])
plot(sf::st_geometry(buildings), add = T)
plot(sf::st_geometry(zObj[zObj$Id == 6, ]), col = "red", add = T)
```

![plot of chunk unnamed-chunk-11](figure/unnamed-chunk-11-1.png)

Alternatively, the intersection can return a clipped set of buildings.

```r
zClip <- zonalIndex(buildings, clusters, zoneField = "Id", clip = T)

plot(sf::st_geometry(clusters)[[6]])
plot(sf::st_geometry(buildings), add = T)
plot(sf::st_geometry(zClip[zClip$Id == 6, ]), col = "red", add = T)
```

![plot of chunk unnamed-chunk-12](figure/unnamed-chunk-12-1.png)

This option clips the footprints via intersection, potentially leaving small
slivers of structures in the zone which will affect the feature statistics.

An additional side effect of the intersection is that overlapping zones are
allowed and this duplicates and associates the footprints into both zones.


```r
# create a temporary shape by shifting one cluster
newClusters <- st_sfc(sf::st_geometry(clusters)[[1]], sf::st_cast(sf::st_geometry(clusters)[[1]] + 
    c(0.001, 1e-04), "POLYGON"), crs = sf::st_crs(clusters))

newClusters <- st_sf(geometry = newClusters, crs = sf::st_crs(clusters))

newObj <- zonalIndex(buildings, newClusters, clip = T)

# areas of overlap are in a purple hue
plot(sf::st_geometry(newClusters))
plot(sf::st_geometry(newObj[newObj$zoneID == 1, ]), col = "red", add = T)
plot(sf::st_geometry(newObj[newObj$zoneID == 2, ]), col = sf::sf.colors(n = 1, alpha = 0.5), 
    add = T)
plot(sf::st_geometry(buildings), add = T)
```

![plot of chunk unnamed-chunk-13](figure/unnamed-chunk-13-1.png)

These side effects are allowed because they allow for flexibility to support
types of "focal" summaries of statistics and to produce a true gridded measure
of footprint metrics.


## Calculating multiple metrics
The `calculate_footstats()` function provides a convenient wrapper to the
individual footprint statistic functions and other helper functions. The
function accepts a variety of input formats (see `?calculate_footstats`).
Multiple metrics can be calculated for the same sets of buildings and zones.


```r
# Creates zonal index and calculates multiple metrics
results <- calculate_footstats(buildings, 
                               adminzones, 
                               metrics=c("fs_area_mean","fs_area_cv"), 
                               gridded=F)
#> although coordinates are longitude/latitude, st_intersects assumes that they are planar
  print(results)  
#>     index  fs_area_ha_mean fs_area_cv
#>  1:     1 0.040259838 [ha]  1.2479809
#>  2:     2 0.021105341 [ha]  1.1069491
#>  3:     3 0.052507469 [ha]  1.9194754
#>  4:     4 0.055509314 [ha]  3.8206699
#>  5:     5 0.056871544 [ha]  1.7000587
#>  6:     6 0.102195294 [ha]  2.0652377
#>  7:     7 0.202770402 [ha]  1.4077033
#>  8:     8 0.090824803 [ha]  1.4225521
#>  9:     9 0.018168220 [ha]  1.6104922
#> 10:    10 0.025199721 [ha]  1.5272718
#> 11:    11 0.022011253 [ha]  1.4300230
#> 12:    12 0.008783690 [ha]  1.2659928
#> 13:    13 0.066161890 [ha]  1.7191007
#> 14:    14 0.008185444 [ha]  0.3447115
#> 15:    15 0.008078532 [ha]  1.0115881
#> 16:    16 0.006875161 [ha]  0.5102143
#> 17:    17 0.013917524 [ha]  0.8678702
#> 18:    18 0.008723691 [ha]  1.5248900
#> 19:    19 0.023707627 [ha]  0.6189696
#> 20:    20 0.019939362 [ha]  0.9103598
#> 21:    21 0.024409906 [ha]  2.4147823
#> 22:    22 0.019239558 [ha]  0.3464272
#> 23:    23 0.077600000 [ha]  2.1447695
#> 24:    24 0.021927229 [ha]  0.7972001
#> 25:    25 0.050622155 [ha]  1.3228666
#> 26:    26 0.112964270 [ha]  1.7076343
#> 27:    27 0.022800865 [ha]  2.2623265
#> 28:    29 0.023876025 [ha]  2.7887959
#> 29:    30 0.020368136 [ha]  0.8303153
#> 30:    31 0.014213649 [ha]         NA
#> 31:    32 0.027276984 [ha]  1.0894764
#> 32:    33 0.041866391 [ha]  0.9787568
#> 33:    34 0.017681732 [ha]  1.3707628
#>     index  fs_area_ha_mean fs_area_cv
```

Note that this function uses the default arguments and units for creating zones
and calculating metrics. For the requested metrics the standard deviation is
required for the CV calculation. This is dependency is added and handled
internally by `calculate_footstats`. Also note that one zone has only one
structure in it, so NA values are returned for the CV.

The argument `metrics` will accept a string or a vector of strings for specific
metric names. Users may also supply `"ALL"` or `"NODIST"` to calculate all
available metrics or all bar the nearest neighbour distance-related ones,
respectively.


## Gridded outputs 
Often the desired output is a gridded dataset of a measure, rather than
summarising metrics to polygon zones. A gridded dataset can be achieved with the
`foot` functions in several ways.

(@) The simplest method is to attach buildings (and summary measures) to grid
cells by their centroid point location. A fast approach is to use cell numbers
as a zonal index.

```r
mgrid <- kampala$mastergrid # ~100m raster layer

# get the cell numbers from the grid
cellIDs <- raster::cellFromXY(mgrid, 
                              sf::st_coordinates(sf::st_centroid(buildings)))
#> Warning in st_centroid.sf(buildings): st_centroid assumes attributes are constant over geometries of x
#> Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon = of_largest_polygon): st_centroid does not give correct centroids for longitude/latitude data
# use these numbers as the zone
gridRes <- calculate_footstats(buildings, 
                               index=cellIDs, 
                               metrics=c("fs_perim_total",
                                         "fs_area_total",
                                         "fs_count",
                                         "fs_settled"),
                               gridded=F)
# buildings lacking a grid cell are NA
gridRes <- na.omit(gridRes)
  gridRes
#>      index fs_settled fs_count fs_area_ha_total fs_perim__total
#>   1:     1          1        1 0.030170228 [ha]    79.27521 [m]
#>   2:     2          1        4 0.112942319 [ha]   275.12308 [m]
#>   3:     3          1        5 0.138862915 [ha]   356.61070 [m]
#>   4:     4          1        6 0.128857046 [ha]   351.05542 [m]
#>   5:     5          1        3 0.069463158 [ha]   209.95544 [m]
#>  ---                                                           
#> 781:   892          1        4 0.090691170 [ha]   247.10057 [m]
#> 782:   893          1        2 0.191112517 [ha]   317.01344 [m]
#> 783:   897          1        6 0.059662965 [ha]   236.90637 [m]
#> 784:   898          1        4 0.042424995 [ha]   166.82738 [m]
#> 785:   900          1        1 0.008472198 [ha]    38.63609 [m]
  
# create a blank raster and fill with summary measures
outSettled <- mgrid
outSettled[] <- NA
# `$index` are the cell numbers from the raster 
outSettled[gridRes$index] <- gridRes$fs_area_ha_total

outCount <- mgrid
outCount[] <- NA
outCount[gridRes$index] <- gridRes$fs_count

raster::plot(outCount)
plot(sf::st_geometry(buildings), add=T)
```

![plot of chunk unnamed-chunk-15](figure/unnamed-chunk-15-1.png)

(@) Pixel-level calculation. While centroid-based calculations are fast,
sometimes it may be necessary to know the true amount of settlement *per pixel*.
The zonal index functions can be used to intersect buildings to grid squares,
and then supply those "pixels" as zones to the feature calculations as shown.

```r
# convert the grid to a `stars` object and then `sf` to get polygons
sgrid <- stars::st_as_stars(mgrid)
sgrid <- sf::st_as_sf(sgrid)

# add a cell number ID to the grid polygons
sgrid$cellIDs <- raster::cellFromXY(mgrid, sf::st_coordinates(sf::st_centroid(sgrid)))

# create a zonal index on the building objects
pxZone <- zonalIndex(buildings, 
                     sgrid, 
                     "cellIDs", 
                     returnObject=T, 
                     clip=T)

pxResult <- calculate_footstats(pxZone, 
                                index="cellIDs",
                                metrics=c("fs_area_total", "fs_settled"))
  print(pxResult)
#>      index fs_settled  fs_area_ha_total
#>   1:     1          1 2.676570e-02 [ha]
#>   2:     2          1 1.086126e-01 [ha]
#>   3:     3          1 1.509693e-01 [ha]
#>   4:     4          1 1.539263e-01 [ha]
#>   5:     5          1 6.933793e-02 [ha]
#>  ---                                   
#> 835:   894          1 4.767962e-05 [ha]
#> 836:   897          1 6.184597e-02 [ha]
#> 837:   898          1 3.986828e-02 [ha]
#> 838:   899          1 1.304506e-03 [ha]
#> 839:   900          1 6.687084e-03 [ha]
```

As before, the metrics are linked to the grid by their cell numbers. The results
can also be merged to the `stars` or `sf` representation of the grid and quickly
rasterized based on geometry. The difference between using centroids or pixels
is most visible with large structures.

```r
# create output
pxSettled <- mgrid
pxSettled[] <- NA
pxSettled[pxResult$index] <- pxResult$fs_area_ha_total

# compare centroid and pixel settled maps
par(mfrow = c(1, 2))
raster::plot(outSettled, zlim = c(0, 1), xlim = c(32.623, 32.626), ylim = c(0.338, 
    0.342))
plot(sf::st_geometry(buildings), add = T)
raster::plot(pxSettled, zlim = c(0, 1), xlim = c(32.623, 32.626), ylim = c(0.338, 
    0.342))
plot(sf::st_geometry(buildings), add = T)
```

![Centroid-based (left) and a pixel-based (right) map of total building area](figure/unnamed-chunk-17-1.png)

(@) Write gridded data to GeoTiff files. Using `calculate_footstats` a template
raster and an output location can be specified. The template can be a `raster`
or `stars` object. Each metric will be written to a separate grid. This approach
builds on using an `sf` object to define the summary zone directly in the call
to the wrapper function.

```r
outputPath <- tempdir()

# re-using the sf pixels as "zones"
calculate_footstats(buildings, 
                    index=sgrid, 
                    metrics=c("fs_area_mean", "fs_settled"),
                    gridded=TRUE, 
                    template=mgrid,  # using a rasterlayer
                    outputPath=outputPath # or a temp directory is created
                   )
#> although coordinates are longitude/latitude, st_intersects assumes that they are planar
#> Warning in dir.create(outputPath): '/tmp/RtmprZs5pk' already exists
#>      index fs_settled  fs_area_ha_mean
#>   1:     1          1 0.030170228 [ha]
#>   2:     2          1 0.027039204 [ha]
#>   3:     3          1 0.024465687 [ha]
#>   4:     4          1 0.026389713 [ha]
#>   5:     5          1 0.023045401 [ha]
#>  ---                                  
#> 835:   894          1 0.146420223 [ha]
#> 836:   897          1 0.011029982 [ha]
#> 837:   898          1 0.011290191 [ha]
#> 838:   899          1 0.010422231 [ha]
#> 839:   900          1 0.008472198 [ha]

# get the output
raster::plot(raster::raster(paste0(outputPath, "/fs_area_ha_mean.tif")))
plot(st_geometry(buildings), add=T)
```

![plot of chunk unnamed-chunk-18](figure/unnamed-chunk-18-1.png)

The above approaches work fine for small study areas, but may be too slow over
large areas and with many footprint features. Producing country-scale gridded
datasets with tools from `foot` is addressed in the second vignette ("bigfoot").


***

```r
sessionInfo()
#> R version 3.6.3 (2020-02-29)
#> Platform: x86_64-pc-linux-gnu (64-bit)
#> Running under: Ubuntu 20.04.1 LTS
#> 
#> Matrix products: default
#> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
#> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
#> 
#> locale:
#>  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C               LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8     LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8    LC_PAPER=en_GB.UTF-8      
#>  [8] LC_NAME=C                  LC_ADDRESS=C               LC_TELEPHONE=C             LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
#> 
#> attached base packages:
#> [1] stats     graphics  grDevices utils     datasets  methods   base     
#> 
#> other attached packages:
#> [1] sf_0.9-2   foot_0.4.1 knitr_1.28
#> 
#> loaded via a namespace (and not attached):
#>  [1] Rcpp_1.0.4.6       lattice_0.20-40    prettyunits_1.1.1  class_7.3-16       ps_1.3.2           foreach_1.4.8      assertthat_0.2.1   rprojroot_1.3-2    digest_0.6.25      R6_2.4.1          
#> [11] backports_1.1.5    evaluate_0.14      e1071_1.7-3        highr_0.8          pillar_1.4.3       rlang_0.4.5        rstudioapi_0.11    data.table_1.12.8  callr_3.4.3        raster_3.1-5      
#> [21] rmarkdown_2.1      pkgdown_1.6.1      desc_1.2.0         devtools_2.3.0     rgdal_1.4-8        stringr_1.4.0      compiler_3.6.3     xfun_0.12          pkgconfig_2.0.3    pkgbuild_1.0.6    
#> [31] rgeos_0.5-2        htmltools_0.4.0    mmap_0.6-19        tidyselect_1.0.0   tibble_3.0.1       codetools_0.2-16   fansi_0.4.1        crayon_1.3.4       dplyr_0.8.5        withr_2.1.2       
#> [41] grid_3.6.3         lwgeom_0.2-3       lifecycle_0.2.0    DBI_1.1.0          git2r_0.26.1       magrittr_1.5       formatR_1.7        units_0.6-6        KernSmooth_2.23-16 cli_2.0.2         
#> [51] stringi_1.4.6      fs_1.3.1           remotes_2.1.1      doParallel_1.0.15  sp_1.4-1           testthat_2.3.2     filelock_1.0.2     ellipsis_0.3.0     vctrs_0.2.4        rematch2_2.1.1    
#> [61] iterators_1.0.12   tools_3.6.3        glue_1.4.0         purrr_0.3.3        processx_3.4.2     abind_1.4-5        pkgload_1.0.2      parallel_3.6.3     yaml_2.2.1         sessioninfo_1.1.1 
#> [71] stars_0.4-1        classInt_0.4-3     memoise_1.1.0      usethis_1.6.1
```

