---
title: "Basic building footprint calculations"
date: 'October 20, 2020'
description: >
  Building footprints or polygons representing the outline shape of structures
  can provide a unique data source for studying urban areas at high spatial
  resolutions. This vignette will introduce the `foot` package and demonstrate
  some of the tools provided to calculate summary measures of geometric
  properties and to produce tabular, zonal, and gridded outputs.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic building footprint calculations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



The `foot` package was developed by WorldPop at the University of Southampton
([www.worldpop.org](https://www.worldpop.org)) to provide a set of consistent
and flexible tools for processing 2D vector representations of buildings (e.g.
"footprints") and calculating urban morphology measurements. The functionality
includes basic geometry and morphology characteristics, distance and clustering
metrics. These calculations are supported with helper functions for spatial
intersections and tiled reading/writing of data.


```r
library(foot)
```

This vignette will demonstrate some of the core functionality in the package,
including:

* The available measurements and summary statistics
* How to define different types of spatial zones for area-level summaries
* Calculating multiple summary metrics for a set of spatial areas
* Example workflows to produce outputs using `foot::calculate_footstats()`.

To demonstrate the package, this vignette will use a supplied sample of building
footprint polygons produced by Microsoft Bing Maps
([Source](https://github.com/microsoft/Uganda-Tanzania-Building-Footprints))
from an area in Kampala, Uganda. These footprints have been reprocessed into a
spatial data format which can be read with `sf`.

## Load the sample dataset


```r
data("kampala", package = "foot")

buildings <- kampala$buildings
adminzones <- kampala$adminZones
clusters <- kampala$clusters
```

The sample dataset is a list of four named objects: 

* "buildings" - polygons of building footprints in `sf` format. Contains 8480
records. 
* "mastergrid" - geoTiff `RasterLayer` aligned to WorldPop datalayers. This will
be used as a template for producing other gridded outputs
* "adminZones" - 34 polygons in `sf` format for zonal statistics 
* "clusters" - 10 small polygons in `sf` format for sample sites

Note that the adminZones and cluster boundaries are purely artificial and were
created for demonstration purposes only.

For more information, see `?kampala`.

![Sample buildings and zones in Kampala](figure/unnamed-chunk-3-1.png)

## Calculations with `foot`

The core functions of `foot` are provided by `calculate_footstats()`. The
operations include: 1) calculating geometry measures for each footprint, 2)
summarising one or more geometry measures of footprints within zones. The
simplest usage involves supplying a set of building footprint polygons and the
desired characteristics to calculate. All operations return the same format - a
`data.table`, optionally with a column for the index and the named column for
the summarised footprint metric(s).


```r
# the area and perimeter of each building footprint
built_area <- calculate_footstats(buildings, what = list("area", "perimeter"))
#> Selecting metrics 
#> Setting control values. 
#> Pre-calculating areas 
#> Pre-calculating perimeters 
#> No summary functions found, returning metrics.

head(built_area)
#>               area    perimeter
#> 1:  22.00824 [m^2] 19.26045 [m]
#> 2: 220.39011 [m^2] 67.95023 [m]
#> 3:  38.95750 [m^2] 25.37269 [m]
#> 4: 386.74429 [m^2] 98.55654 [m]
#> 5: 349.57765 [m^2] 82.22555 [m]
#> 6: 164.00931 [m^2] 55.87172 [m]
```

To summarise the footprint characteristics over all building polygons, the name
of a summary function, or a list of multiple functions can be supplied.


```r
# the average and standard deviation of all building areas
calculate_footstats(buildings, what = "area", how = list("mean", "sd"))
#> Selecting metrics 
#> Setting control values. 
#> Pre-calculating areas 
#> 
#> Calculating  2  metrics ... 
#>    area mean  
#>    area sd  
#> Finished calculating metrics.
#>    zoneID      area_mean area_sd
#> 1:      1 263.1865 [m^2]  715.28
```

### Available metrics and summary measures

Currently implemented are measures for:

* building presence
* area
* perimeter
* nearest neighbour distance
* angle of rotation
* compactness and shape

A table of metrics and other packaged summary function names available for each
is available using `list_fs()`. The results of this function provide "cols" and
"funs" which can be passed as `what` and `how` arguments, respectively, to
`calculate_footstats`.


```r
# get all available built-in functions for perimeter calculations
argsList <- list_fs(what = "perimeter")

calculate_footstats(buildings, what = argsList$cols, how = argsList$funs)
#> Selecting metrics 
#> Setting control values. 
#> Pre-calculating perimeters 
#> 
#> Calculating  7  metrics ... 
#>    perimeter cv  
#>    perimeter max  
#>    perimeter mean  
#>    perimeter median  
#>    perimeter min  
#>    perimeter sd  
#>    perimeter sum  
#> Finished calculating metrics.
#>    zoneID perimeter_cv perimeter_max perimeter_mean perimeter_median perimeter_min perimeter_sd perimeter_sum
#> 1:      1    0.9396027  1089.097 [m]   62.22027 [m]     46.68314 [m]  14.88332 [m]     58.46233  301146.1 [m]
```

With no other argument supplied, all the footprints are treated as coming from
the same spatial zone for any summary function. A later section describes the
process for identifying zones.

## Additional characteristics and geometry measures

Whenever possible, `foot` makes use of generic functions within `R`. Most
low-level geometry calculations rely on `sf` and `lwgeom` and users need to have
recent versions of these packages installed. There are other stand-alone
functions within `foot` to support more complex or less-common measurements.

### Nearest neighbour distances

Distances can be calculated between footprints, or between footprints and other
spatial objects. The distances can be measured edge-to-edge (`method="poly"`) or
the centroids of the building footprints can be used (`method="centroid"`).


```r
# nearest distance for the first 10 buildings to any other building measured
# between polygon edges
fs_nndist(buildings[1:10, ], buildings, maxSearch = 200, unit = "m")
#> Units: [m]
#>  [1]  3.961359  7.894813  1.019971 22.306277  2.484471 16.257603  0.951225  1.864305  2.607113  2.291474

# omitting argument 'Y' measures distance among the footprints supplied setting
# maxSearch=NULL removes the search restriction
fs_nndist(buildings[1:10, ], method = "centroid", maxSearch = NULL)
#> Units: [m]
#>  [1]  99.95859  99.95859  90.11091  90.11091 116.64498 116.64498 217.86037 228.63068 217.86037 438.91352
```

Note that distance calculations are slower for polygons and for unprojected
coordinate systems. The centroid-based calculations are fast. It is recommended
that a maximum search radius is always used. Internally the calculations are
done with a `data.table` to benefit from multi-threading capabilities.

### Rotation angles

A less conventional geometric measure is derived from the rotated bounding
rectangle. This is the rectangle enclosing a footprint polygon which
has been rotated to minimise the area. In contrast, a "bounding box" for a shape
is always oriented along the x and y axes.


```r
# To obtain the rotated rectangle as a spatial object
mbr <- fs_mbr(buildings[4502, ], returnShape = T)

plot(sf::st_geometry(buildings[4502, ]), col = "grey")
plot(mbr, border = "red", lwd = 2, add = T)
```

![plot of chunk unnamed-chunk-8](figure/unnamed-chunk-8-1.png)

```r

# Or obtain just the angle measure
fs_mbr(buildings[4502, ], returnShape = F)
#>        X 
#> 63.25363
```

The angles can be summarised as an entropy measure and normalised to describe
how much the angles of a set of structures depart from a regular grid pattern 
(available in `calculate_footstats` where `how="entropy"`). 

## Creating and supplying zone indices

Rather than treating all footprints features as belonging to a single summary
zone, it's more common to want to summarise metrics within smaller areas. There
are several ways to supply information on the zones.

### Index by vector

A vector of indices for the zones can be supplied to `foot` functions as a 1)
column name within the footprints, 2) a standalone numeric vector of indices, or
3) a spatial polygons object to join to the building footprints. The length of a
vector of indices must match the number of building polygons.


```r
# create a vector of ten random zones
idx <- sample(1:10, nrow(buildings), replace = T)
buildings$id <- idx  # add it to the buildings object
table(buildings$id)  # splitting observations into 10 groups
#> 
#>   1   2   3   4   5   6   7   8   9  10 
#> 481 485 473 493 485 462 479 484 493 505

# 1. pass the index by name
colnames(buildings)
#> [1] "FID_1"    "geometry" "id"
calculate_footstats(buildings, "id", what = "area", how = "mean", verbose = FALSE)
#>     id      area_mean
#>  1:  1 245.0530 [m^2]
#>  2:  2 296.6654 [m^2]
#>  3:  3 250.3406 [m^2]
#>  4:  4 257.1753 [m^2]
#>  5:  5 300.0085 [m^2]
#>  6:  6 268.8176 [m^2]
#>  7:  7 309.9961 [m^2]
#>  8:  8 263.2904 [m^2]
#>  9:  9 215.3597 [m^2]
#> 10: 10 227.8819 [m^2]

# 2. pass the index as a standalone vector
calculate_footstats(buildings, idx, what = "settled", how = "count", verbose = FALSE)
#>     zoneID settled_count
#>  1:      1           481
#>  2:      2           485
#>  3:      3           473
#>  4:      4           493
#>  5:      5           485
#>  6:      6           462
#>  7:      7           479
#>  8:      8           484
#>  9:      9           493
#> 10:     10           505

# 3. pass a separate spatial object of zones
calculate_footstats(buildings, zone = adminzones, what = "angle", how = "entropy", 
    verbose = FALSE)
#>     zoneID angle_entropy
#>  1:      1     0.9351095
#>  2:      2     0.3108829
#>  3:      3     0.5849276
#>  4:      4     0.2003194
#>  5:      5     0.6678707
#>  6:      6     0.7139565
#>  7:      7     0.9691374
#>  8:      8     0.6102641
#>  9:      9     0.5110688
#> 10:     10     0.7309444
#> 11:     11     0.3933987
#> 12:     12     0.4602628
#> 13:     13     1.0000000
#> 14:     14     0.4656334
#> 15:     15     0.3129308
#> 16:     16     0.4551733
#> 17:     17     0.3864071
#> 18:     18     0.6949125
#> 19:     19     0.2928137
#> 20:     20     0.4598566
#> 21:     21     0.6047045
#> 22:     22     0.6520860
#> 23:     23     0.2425743
#> 24:     24     0.4518750
#> 25:     25     0.8426361
#> 26:     26     0.7302834
#> 27:     27     0.4325040
#> 28:     29     0.6144511
#> 29:     30     0.4754793
#> 30:     31     0.6023774
#> 31:     32     0.4508777
#> 32:     33     0.8639418
#> 33:     34     0.1613791
#>     zoneID angle_entropy
```

### Index by shape

Rather than supplying a pre-calculated column or vector of zonal indices,
buildings can be assigned a zone based on a spatial join. When the index is
created in the building footprints, it will be named "zoneID" or a
user-specified name. 


```r
# examine the other objects
head(adminzones)
#> Simple feature collection with 6 features and 1 field
#> geometry type:  POLYGON
#> dimension:      XY
#> bbox:           xmin: 32.60589 ymin: 0.3277355 xmax: 32.62531 ymax: 0.3388665
#> geographic CRS: WGS 84
#>   Id                       geometry
#> 1  1 POLYGON ((32.61231 0.327771...
#> 2  2 POLYGON ((32.61034 0.335317...
#> 3  3 POLYGON ((32.61592 0.327757...
#> 4  4 POLYGON ((32.6214 0.3277355...
#> 5  5 POLYGON ((32.62342 0.333760...
#> 6  6 POLYGON ((32.62498 0.335199...
head(clusters)
#> Simple feature collection with 6 features and 1 field
#> geometry type:  POLYGON
#> dimension:      XY
#> bbox:           xmin: 32.60624 ymin: 0.3303863 xmax: 32.63375 ymax: 0.3472696
#> geographic CRS: WGS 84
#>   Id                       geometry
#> 1  1 POLYGON ((32.6066 0.3398617...
#> 2  2 POLYGON ((32.61151 0.337602...
#> 3  3 POLYGON ((32.61028 0.331954...
#> 4  4 POLYGON ((32.61649 0.344649...
#> 5  5 POLYGON ((32.62552 0.345516...
#> 6  6 POLYGON ((32.63225 0.340927...

# Return a table of index values based on administrative zone polygons using the
# standalone function within `foot`
zID <- zonalIndex(buildings, adminzones, returnObject = F)
head(zID, 10)  # the xID column are row numbers to object X
#>      xID zoneID
#>  1:  145      1
#>  2:  338      1
#>  3:  655      1
#>  4:  995      1
#>  5: 2869      1
#>  6: 3164      1
#>  7: 3263      1
#>  8: 3314      1
#>  9: 3407      1
#> 10: 3454      1

# Alternatively (and preferably), join zones to create a new footprint object A
# custom zone name can be used but must be specificed to the summary functions
zObj <- zonalIndex(buildings, clusters, zoneField = "Id", returnObject = T)
zObj
#> Simple feature collection with 348 features and 3 fields
#> geometry type:  POLYGON
#> dimension:      XY
#> bbox:           xmin: 32.60631 ymin: 0.328119 xmax: 32.63543 ymax: 0.349785
#> geographic CRS: WGS 84
#> First 10 features:
#>    FID_1 id Id                       geometry
#> 1   6293  5  1 POLYGON ((32.60744 0.338575...
#> 2  17706  7  1 POLYGON ((32.60664 0.339347...
#> 3  29106  4  1 POLYGON ((32.60719 0.339276...
#> 4  53393  3  1 POLYGON ((32.60779 0.339691...
#> 5  57187  1  1 POLYGON ((32.60826 0.338663...
#> 6  59496  6  1 POLYGON ((32.60692 0.339387...
#> 7  68588  7  1 POLYGON ((32.60791 0.338896...
#> 8  68590  7  1 POLYGON ((32.60768 0.339633...
#> 9  72387  1  1 POLYGON ((32.60777 0.338962...
#> 10 78504  5  1 POLYGON ((32.60702 0.338636...
```

When using a new spatial object which has been joined to its zones, remember to
supply the name of the zone field to `calculate_foostats`.


```r
# use the new object and zone field 'Id' in a summary calculation
colnames(zObj)
#> [1] "FID_1"    "id"       "Id"       "geometry"

zarea <- calculate_footstats(zObj, zone = "Id", what = "area", how = "mean", verbose = F)
clusters <- merge(clusters, zarea, by = "Id")
plot(sf::st_geometry(adminzones))
plot(clusters["area_mean"], add = T)
```

![plot of chunk unnamed-chunk-11](figure/unnamed-chunk-11-1.png)

The `zonalIndex` function works by spatial intersection. This produces some
(potentially useful) side effects that users need to be aware of.

The default behaviour (see `method`) is to assign a building to a zone based on
its **centroid**.

```r
# Note the selected structures extend beyond the cluster boundary
plot(sf::st_geometry(clusters)[[6]])
plot(sf::st_geometry(buildings), add = T)
plot(sf::st_geometry(zObj[zObj$Id == 6, ]), col = "red", add = T)
plot(sf::st_geometry(sf::st_centroid(zObj[zObj$Id == 6, ])), pch = 16, add = T)
```

![plot of chunk unnamed-chunk-12](figure/unnamed-chunk-12-1.png)

Alternatively, an intersection can be used to assign footprints to any zones
which are intersected. The whole footprint is associated, even if the shape is
not "contained" by the zone.

```r
# Note the selected structures extend beyond the cluster boundary
zInt <- zonalIndex(buildings, clusters, zoneField = "Id", method = "intersect")

plot(sf::st_geometry(clusters)[[6]])
plot(sf::st_geometry(buildings), add = T)
plot(sf::st_geometry(zInt[zInt$Id == 6, ]), col = "red", add = T)
```

![plot of chunk unnamed-chunk-13](figure/unnamed-chunk-13-1.png)

Finally, the intersection can return a clipped set of buildings.

```r
zClip <- zonalIndex(buildings, clusters, zoneField = "Id", method = "clip")

plot(sf::st_geometry(clusters)[[6]])
plot(sf::st_geometry(buildings), add = T)
plot(sf::st_geometry(zClip[zClip$Id == 6, ]), col = "red", add = T)
```

![plot of chunk unnamed-chunk-14](figure/unnamed-chunk-14-1.png)

This third option clips the footprints via intersection, potentially leaving
small slivers of structures in the zone which will affect the feature
statistics.

An additional side effect of the intersection operation is that overlapping
zones are allowed, and this can duplicate and associate footprints into both
(overlapping) zones.


```r
# create a temporary shape by shifting one cluster
newClusters <- st_sfc(sf::st_geometry(clusters)[[1]], sf::st_cast(sf::st_geometry(clusters)[[1]] + 
    c(0.001, 1e-04), "POLYGON"), crs = sf::st_crs(clusters))

newClusters <- st_sf(geometry = newClusters, crs = sf::st_crs(clusters))

newObj <- zonalIndex(buildings, newClusters, method = "clip")

# areas of overlap are in a purple hue
plot(sf::st_geometry(newClusters))
plot(sf::st_geometry(newObj[newObj$zoneID == 1, ]), col = "red", add = T)
plot(sf::st_geometry(newObj[newObj$zoneID == 2, ]), col = sf::sf.colors(n = 1, alpha = 0.5), 
    add = T)
plot(sf::st_geometry(buildings), add = T)
```

![plot of chunk unnamed-chunk-15](figure/unnamed-chunk-15-1.png)

These side effects are allowed because they allow for flexibility to support
types of "focal" summaries of statistics and to produce a true gridded measure
of footprint metrics.

## Calculating multiple metrics

The `calculate_footstats()` function provides a convenient wrapper to the
individual footprint statistics and as well to `zonalIndex`. The function
accepts a variety of input formats (see `?calculate_footstats`). Multiple
metrics can be calculated for the same sets of buildings and zones.


```r
# Creates a zonal index and calculates multiple metrics
# Use the intersection method define zones
results <- calculate_footstats(buildings, 
                               zone=adminzones, 
                               what="area",
                               how=list("mean","cv"),
                               controlZone=list(method="intersect"),
                               verbose=F
                              )
  results
#>     zoneID        area_mean   area_cv
#>  1:      1  402.59838 [m^2] 1.2479809
#>  2:      2  211.05341 [m^2] 1.1069491
#>  3:      3  525.07469 [m^2] 1.9194754
#>  4:      4  555.09314 [m^2] 3.8206699
#>  5:      5  568.71544 [m^2] 1.7000587
#>  6:      6 1021.95294 [m^2] 2.0652377
#>  7:      7 2027.70402 [m^2] 1.4077033
#>  8:      8  908.24803 [m^2] 1.4225521
#>  9:      9  181.68220 [m^2] 1.6104922
#> 10:     10  251.99721 [m^2] 1.5272718
#> 11:     11  220.11253 [m^2] 1.4300230
#> 12:     12   87.83690 [m^2] 1.2659928
#> 13:     13  661.61890 [m^2] 1.7191007
#> 14:     14   81.85444 [m^2] 0.3447115
#> 15:     15   80.78532 [m^2] 1.0115881
#> 16:     16   68.75161 [m^2] 0.5102143
#> 17:     17  139.17524 [m^2] 0.8678702
#> 18:     18   87.23691 [m^2] 1.5248900
#> 19:     19  237.07627 [m^2] 0.6189696
#> 20:     20  199.39362 [m^2] 0.9103598
#> 21:     21  244.09906 [m^2] 2.4147823
#> 22:     22  192.39558 [m^2] 0.3464272
#> 23:     23  776.00000 [m^2] 2.1447695
#> 24:     24  219.27229 [m^2] 0.7972001
#> 25:     25  506.22155 [m^2] 1.3228666
#> 26:     26 1129.64270 [m^2] 1.7076343
#> 27:     27  228.00865 [m^2] 2.2623265
#> 28:     29  238.76025 [m^2] 2.7887959
#> 29:     30  203.68136 [m^2] 0.8303153
#> 30:     31  142.13649 [m^2]        NA
#> 31:     32  272.76984 [m^2] 1.0894764
#> 32:     33  418.66391 [m^2] 0.9787568
#> 33:     34  176.81732 [m^2] 1.3707628
#>     zoneID        area_mean   area_cv
```

Multiple metrics can be applied to different groups of characteristics by
providing nested lists of metrics and summary functions. The argument `what`
will accept a string or a list of strings for specific metric names. Users may
also supply `"all"` or `"nodist"` to calculate all available metrics or all bar
the nearest neighbour distance-related ones, respectively.


```r
# Use nested lists to group characteristics and summary functions
results <- calculate_footstats(buildings, 
                               zone=adminzones, 
                               what=list(list("area","perimeter"), 
                                         list("settled")),
                               how=list(list("sum","cv"), 
                                        list("count")),
                               controlZone=list(method="centroid"),
                               verbose=F
                              )
  results
#>     zoneID          area_sum   perimeter_sum   area_cv perimeter_cv settled_count
#>  1:      1   8454.5661 [m^2]  1781.62245 [m] 1.2479809    0.6561304            21
#>  2:      2  29758.5314 [m^2]  8596.30974 [m] 1.1069491    0.7313348           141
#>  3:      3  25728.6600 [m^2]  4414.86934 [m] 1.9194754    0.9811076            49
#>  4:      4  63835.7113 [m^2]  9640.94681 [m] 3.8206699    1.0600954           115
#>  5:      5  26729.6259 [m^2]  4329.10334 [m] 1.7000587    0.9581201            47
#>  6:      6  35768.3531 [m^2]  3835.74843 [m] 2.0652377    0.9616081            35
#>  7:      7  28387.8563 [m^2]  2565.09927 [m] 1.4077033    0.9286094            14
#>  8:      8  44504.1537 [m^2]  6348.37632 [m] 1.4225521    0.8489816            49
#>  9:      9  48145.7825 [m^2] 15739.78807 [m] 1.6104922    0.9246860           265
#> 10:     10   7559.9164 [m^2]  2087.88260 [m] 1.5272718    1.0900293            30
#> 11:     11  24212.3780 [m^2]  7672.66021 [m] 1.4300230    0.8815988           110
#> 12:     12   3109.8042 [m^2]  1403.25960 [m] 1.3014215    0.7257624            36
#> 13:     13   2646.4756 [m^2]   423.87801 [m] 1.7191007    1.3165558             4
#> 14:     14   6712.0641 [m^2]  3088.40482 [m] 0.3447115    0.2059276            82
#> 15:     15  19226.9062 [m^2]  8676.96497 [m] 1.0115881    0.5073846           238
#> 16:     16   9900.2318 [m^2]  4968.39946 [m] 0.5102143    0.3095971           144
#> 17:     17  14752.5754 [m^2]  5213.18182 [m] 0.8678702    0.5541695           106
#> 18:     18  36895.4355 [m^2] 15742.13708 [m] 1.5308486    0.7093738           424
#> 19:     19  96490.0399 [m^2] 26354.10548 [m] 0.6189696    0.4151437           407
#> 20:     20  80355.6287 [m^2] 23566.14546 [m] 0.9103598    0.5257108           403
#> 21:     21  18063.3304 [m^2]  4403.44976 [m] 2.4147823    0.7810948            74
#> 22:     22  10196.9657 [m^2]  3061.47987 [m] 0.3464272    0.2238327            53
#> 23:     23 132673.0618 [m^2] 17464.78357 [m] 2.1625263    1.1205392           172
#> 24:     24  61834.7854 [m^2] 17707.47705 [m] 0.7972001    0.5317242           282
#> 25:     25  11643.0956 [m^2]  2163.70761 [m] 1.3228666    0.8940386            23
#> 26:     26 150208.7190 [m^2] 17604.40321 [m] 1.6814458    1.0767096           129
#> 27:     27  33816.8355 [m^2] 10017.95165 [m] 0.7963207    0.4462858           177
#> 28:     29  37007.8380 [m^2]  9185.83050 [m] 2.7887959    1.0713172           155
#> 29:     30  15276.1021 [m^2]  4621.61764 [m] 0.8303153    0.5426390            75
#> 30:     31    142.1365 [m^2]    48.13661 [m]        NA           NA             1
#> 31:     32  35732.8487 [m^2]  9127.30909 [m] 1.0894764    0.6469339           131
#> 32:     33   7117.2864 [m^2]  1557.24261 [m] 0.9787568    0.6104610            17
#> 33:     34 146935.1905 [m^2] 47733.83601 [m] 1.3707628    0.7474269           831
#>     zoneID          area_sum   perimeter_sum   area_cv perimeter_cv settled_count
```

## Next steps

The `calculate_footstats` function provides the core functionality for
calculating and summarising the characteristics of building footprints. It also
wraps the functionality of assigning footprints to zones based on different
spatial joining techniques. To go further with `foot` the concept of footprint
morphology calculations can be extended to created gridded data. See
`vignette("bigfoot", package="foot")`. Additionally, users can specify their own
custom summary functions to be used with `calculate_footstats`. This and other
advanced options are covered in `vignette("cobbler", package="foot")`.

***

```r
sessionInfo()
#> R version 3.6.3 (2020-02-29)
#> Platform: x86_64-pc-linux-gnu (64-bit)
#> Running under: Ubuntu 20.04.1 LTS
#> 
#> Matrix products: default
#> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
#> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
#> 
#> locale:
#>  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C               LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8     LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8    LC_PAPER=en_GB.UTF-8      
#>  [8] LC_NAME=C                  LC_ADDRESS=C               LC_TELEPHONE=C             LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
#> 
#> attached base packages:
#> [1] stats     graphics  grDevices utils     datasets  methods   base     
#> 
#> other attached packages:
#> [1] knitr_1.28   foot_0.5     sf_0.9-2     raster_3.1-5 sp_1.4-1    
#> 
#> loaded via a namespace (and not attached):
#>  [1] Rcpp_1.0.4.6       lattice_0.20-40    prettyunits_1.1.1  class_7.3-16       ps_1.3.2           assertthat_0.2.1   rprojroot_1.3-2    packrat_0.5.0      digest_0.6.25      foreach_1.4.8     
#> [11] R6_2.4.1           backports_1.1.5    evaluate_0.14      e1071_1.7-3        highr_0.8          pillar_1.4.3       rlang_0.4.5        rstudioapi_0.11    data.table_1.12.8  callr_3.4.3       
#> [21] rmarkdown_2.1      desc_1.2.0         devtools_2.3.0     rgdal_1.4-8        stringr_1.4.0      compiler_3.6.3     xfun_0.12          pkgconfig_2.0.3    pkgbuild_1.0.6     htmltools_0.4.0   
#> [31] tidyselect_1.0.0   tibble_3.0.1       codetools_0.2-16   fansi_0.4.1        crayon_1.3.4       dplyr_0.8.5        withr_2.1.2        grid_3.6.3         lwgeom_0.2-3       lifecycle_0.2.0   
#> [41] DBI_1.1.0          formatR_1.7        magrittr_1.5       units_0.6-6        KernSmooth_2.23-16 cli_2.0.2          stringi_1.4.6      fs_1.3.1           remotes_2.1.1      doParallel_1.0.15 
#> [51] testthat_2.3.2     ellipsis_0.3.0     filelock_1.0.2     vctrs_0.2.4        iterators_1.0.12   tools_3.6.3        glue_1.4.0         purrr_0.3.3        processx_3.4.2     abind_1.4-5       
#> [61] pkgload_1.0.2      parallel_3.6.3     yaml_2.2.1         sessioninfo_1.1.1  stars_0.4-1        classInt_0.4-3     memoise_1.1.0      usethis_1.6.1
```

